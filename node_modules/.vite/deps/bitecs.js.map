{
  "version": 3,
  "sources": ["../../bitecs/src/Constants.js", "../../bitecs/src/Storage.js", "../../bitecs/src/Util.js", "../../bitecs/src/Serialize.js", "../../bitecs/src/Entity.js", "../../bitecs/src/Query.js", "../../bitecs/src/Component.js", "../../bitecs/src/World.js", "../../bitecs/src/System.js", "../../bitecs/src/index.js"],
  "sourcesContent": ["export const TYPES_ENUM = {\r\n  i8: 'i8',\r\n  ui8: 'ui8',\r\n  ui8c: 'ui8c',\r\n  i16: 'i16',\r\n  ui16: 'ui16',\r\n  i32: 'i32',\r\n  ui32: 'ui32',\r\n  f32: 'f32',\r\n  f64: 'f64',\r\n  eid: 'eid',\r\n}\r\n\r\nexport const TYPES_NAMES = {\r\n  i8: 'Int8',\r\n  ui8: 'Uint8',\r\n  ui8c: 'Uint8Clamped',\r\n  i16: 'Int16',\r\n  ui16: 'Uint16',\r\n  i32: 'Int32',\r\n  ui32: 'Uint32',\r\n  eid: 'Uint32',\r\n  f32: 'Float32',\r\n  f64: 'Float64'\r\n}\r\n\r\nexport const TYPES = {\r\n  i8: Int8Array,\r\n  ui8: Uint8Array,\r\n  ui8c: Uint8ClampedArray,\r\n  i16: Int16Array,\r\n  ui16: Uint16Array,\r\n  i32: Int32Array,\r\n  ui32: Uint32Array,\r\n  f32: Float32Array,\r\n  f64: Float64Array,\r\n  eid: Uint32Array,\r\n}\r\n\r\nexport const UNSIGNED_MAX = {\r\n  uint8: 2**8,\r\n  uint16: 2**16,\r\n  uint32: 2**32\r\n}\r\n", "import { TYPES, TYPES_ENUM, TYPES_NAMES, UNSIGNED_MAX } from './Constants.js'\r\n// import { createAllocator } from './Allocator.js'\r\n\r\nconst roundToMultiple = mul => x => Math.ceil(x / mul) * mul\r\nconst roundToMultiple4 = roundToMultiple(4)\r\n\r\nexport const $storeRef = Symbol('storeRef')\r\nexport const $storeSize = Symbol('storeSize')\r\nexport const $storeMaps = Symbol('storeMaps')\r\nexport const $storeFlattened = Symbol('storeFlattened')\r\nexport const $storeBase = Symbol('storeBase')\r\nexport const $storeType = Symbol('storeType')\r\n\r\nexport const $storeArrayElementCounts = Symbol('storeArrayElementCounts')\r\nexport const $storeSubarrays = Symbol('storeSubarrays')\r\nexport const $subarrayCursors = Symbol('subarrayCursors')\r\nexport const $subarray = Symbol('subarray')\r\nexport const $subarrayFrom = Symbol('subarrayFrom')\r\nexport const $subarrayTo = Symbol('subarrayTo')\r\nexport const $parentArray = Symbol('parentArray')\r\nexport const $tagStore = Symbol('tagStore')\r\n\r\nexport const $queryShadow = Symbol('queryShadow')\r\nexport const $serializeShadow = Symbol('serializeShadow')\r\n\r\nexport const $indexType = Symbol('indexType')\r\nexport const $indexBytes = Symbol('indexBytes')\r\n\r\nexport const $isEidType = Symbol('isEidType')\r\n\r\nconst stores = {}\r\n\r\n// const alloc = createAllocator()\r\n\r\nexport const resize = (ta, size) => {\r\n  const newBuffer = new ArrayBuffer(size * ta.BYTES_PER_ELEMENT)\r\n  const newTa = new ta.constructor(newBuffer)\r\n  newTa.set(ta, 0)\r\n  return newTa\r\n}\r\n\r\nexport const createShadow = (store, key) => {\r\n  if (!ArrayBuffer.isView(store)) {\r\n    const shadowStore = store[$parentArray].slice(0)\r\n    store[key] = store.map((_,eid) => {\r\n      const { length } = store[eid]\r\n      const start = length * eid\r\n      const end = start + length\r\n      return shadowStore.subarray(start, end)\r\n    })\r\n  } else {\r\n    store[key] = store.slice(0)\r\n  }\r\n}\r\n\r\nconst resizeSubarray = (metadata, store, storeSize) => {\r\n  const cursors = metadata[$subarrayCursors]\r\n  let type = store[$storeType]\r\n  const length = store[0].length\r\n  const indexType =\r\n    length <= UNSIGNED_MAX.uint8\r\n      ? TYPES_ENUM.ui8\r\n      : length <= UNSIGNED_MAX.uint16\r\n        ? TYPES_ENUM.ui16\r\n        : TYPES_ENUM.ui32\r\n\r\n  if (cursors[type] === 0) {\r\n\r\n    const arrayElementCount = metadata[$storeArrayElementCounts][type]\r\n    \r\n    // // for threaded impl\r\n    // // const summedBytesPerElement = Array(arrayCount).fill(0).reduce((a, p) => a + TYPES[type].BYTES_PER_ELEMENT, 0)\r\n    // // const totalBytes = roundToMultiple4(summedBytesPerElement * summedLength * size)\r\n    // // const buffer = new SharedArrayBuffer(totalBytes)\r\n\r\n    const array = new TYPES[type](roundToMultiple4(arrayElementCount * storeSize))\r\n\r\n    array.set(metadata[$storeSubarrays][type])\r\n    \r\n    metadata[$storeSubarrays][type] = array\r\n    \r\n    array[$indexType] = TYPES_NAMES[indexType]\r\n    array[$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT\r\n  }\r\n\r\n  const start = cursors[type]\r\n  const end = start + (storeSize * length)\r\n  cursors[type] = end\r\n\r\n  store[$parentArray] = metadata[$storeSubarrays][type].subarray(start, end)\r\n\r\n  // pre-generate subarrays for each eid\r\n  for (let eid = 0; eid < storeSize; eid++) {\r\n    const start = length * eid\r\n    const end = start + length\r\n    store[eid] = store[$parentArray].subarray(start, end)\r\n    store[eid][$indexType] = TYPES_NAMES[indexType]\r\n    store[eid][$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT\r\n    store[eid][$subarray] = true\r\n  }\r\n\r\n}\r\n\r\nconst resizeRecursive = (metadata, store, size) => {\r\n  Object.keys(store).forEach(key => {\r\n    const ta = store[key]\r\n    if (Array.isArray(ta)) {\r\n      resizeSubarray(metadata, ta, size)\r\n      store[$storeFlattened].push(ta)\r\n    } else if (ArrayBuffer.isView(ta)) {\r\n      store[key] = resize(ta, size)\r\n      store[$storeFlattened].push(store[key])\r\n    } else if (typeof ta === 'object') {\r\n      resizeRecursive(metadata, store[key], size)\r\n    }\r\n  })\r\n}\r\n\r\nexport const resizeStore = (store, size) => {\r\n  if (store[$tagStore]) return\r\n  store[$storeSize] = size\r\n  store[$storeFlattened].length = 0\r\n  Object.keys(store[$subarrayCursors]).forEach(k => {\r\n    store[$subarrayCursors][k] = 0\r\n  })\r\n  resizeRecursive(store, store, size)\r\n}\r\n\r\nexport const resetStore = store => {\r\n  if (store[$storeFlattened]) {\r\n    store[$storeFlattened].forEach(ta => {\r\n      ta.fill(0)\r\n    })\r\n    Object.keys(store[$storeSubarrays]).forEach(key => {\r\n      store[$storeSubarrays][key].fill(0)\r\n    })\r\n  }\r\n}\r\n\r\nexport const resetStoreFor = (store, eid) => {\r\n  if (store[$storeFlattened]) {\r\n    store[$storeFlattened].forEach(ta => {\r\n      if (ArrayBuffer.isView(ta)) ta[eid] = 0\r\n      else ta[eid].fill(0)\r\n    })\r\n  }\r\n}\r\n\r\nconst createTypeStore = (type, length) => {\r\n  const totalBytes = length * TYPES[type].BYTES_PER_ELEMENT\r\n  const buffer = new ArrayBuffer(totalBytes)\r\n  const store = new TYPES[type](buffer)\r\n  store[$isEidType] = type === TYPES_ENUM.eid\r\n  return store\r\n}\r\n\r\nexport const parentArray = store => store[$parentArray]\r\n\r\nconst createArrayStore = (metadata, type, length) => {\r\n  const storeSize = metadata[$storeSize]\r\n  const store = Array(storeSize).fill(0)\r\n  store[$storeType] = type\r\n  store[$isEidType] = type === TYPES_ENUM.eid\r\n\r\n  const cursors = metadata[$subarrayCursors]\r\n  const indexType =\r\n    length <= UNSIGNED_MAX.uint8\r\n      ? TYPES_ENUM.ui8\r\n      : length <= UNSIGNED_MAX.uint16\r\n        ? TYPES_ENUM.ui16\r\n        : TYPES_ENUM.ui32\r\n\r\n  if (!length) throw new Error('bitECS - Must define component array length')\r\n  if (!TYPES[type]) throw new Error(`bitECS - Invalid component array property type ${type}`)\r\n\r\n  // create buffer for type if it does not already exist\r\n  if (!metadata[$storeSubarrays][type]) {\r\n    const arrayElementCount = metadata[$storeArrayElementCounts][type]\r\n\r\n    // for threaded impl\r\n    // const summedBytesPerElement = Array(arrayCount).fill(0).reduce((a, p) => a + TYPES[type].BYTES_PER_ELEMENT, 0)\r\n    // const totalBytes = roundToMultiple4(summedBytesPerElement * summedLength * size)\r\n    // const buffer = new SharedArrayBuffer(totalBytes)\r\n\r\n    const array = new TYPES[type](roundToMultiple4(arrayElementCount * storeSize))\r\n    array[$indexType] = TYPES_NAMES[indexType]\r\n    array[$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT\r\n\r\n    metadata[$storeSubarrays][type] = array\r\n    \r\n  }\r\n\r\n  const start = cursors[type]\r\n  const end = start + (storeSize * length)\r\n  cursors[type] = end\r\n\r\n  store[$parentArray] = metadata[$storeSubarrays][type].subarray(start, end)\r\n\r\n  // pre-generate subarrays for each eid\r\n  for (let eid = 0; eid < storeSize; eid++) {\r\n    const start = length * eid\r\n    const end = start + length\r\n    store[eid] = store[$parentArray].subarray(start, end)\r\n    store[eid][$indexType] = TYPES_NAMES[indexType]\r\n    store[eid][$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT\r\n    store[eid][$subarray] = true\r\n  }\r\n\r\n  return store\r\n}\r\n\r\nconst isArrayType = x => Array.isArray(x) && typeof x[0] === 'string' && typeof x[1] === 'number'\r\n\r\nexport const createStore = (schema, size) => {\r\n  const $store = Symbol('store')\r\n\r\n  if (!schema || !Object.keys(schema).length) {\r\n    // tag component\r\n    stores[$store] = {\r\n      [$storeSize]: size,\r\n      [$tagStore]: true,\r\n      [$storeBase]: () => stores[$store]\r\n    }\r\n    return stores[$store]\r\n  }\r\n\r\n  schema = JSON.parse(JSON.stringify(schema))\r\n\r\n  const arrayElementCounts = {}\r\n  const collectArrayElementCounts = s => {\r\n    const keys = Object.keys(s)\r\n    for (const k of keys) {\r\n      if (isArrayType(s[k])) {\r\n        if (!arrayElementCounts[s[k][0]]) arrayElementCounts[s[k][0]] = 0\r\n        arrayElementCounts[s[k][0]] += s[k][1]\r\n      } else if (s[k] instanceof Object) {\r\n        collectArrayElementCounts(s[k])\r\n      }\r\n    }\r\n  }\r\n  collectArrayElementCounts(schema)\r\n\r\n  const metadata = {\r\n    [$storeSize]: size,\r\n    [$storeMaps]: {},\r\n    [$storeSubarrays]: {},\r\n    [$storeRef]: $store,\r\n    [$subarrayCursors]: Object.keys(TYPES).reduce((a, type) => ({ ...a, [type]: 0 }), {}),\r\n    [$storeFlattened]: [],\r\n    [$storeArrayElementCounts]: arrayElementCounts\r\n  }\r\n\r\n  if (schema instanceof Object && Object.keys(schema).length) {\r\n\r\n    const recursiveTransform = (a, k) => {\r\n\r\n      if (typeof a[k] === 'string') {\r\n\r\n        a[k] = createTypeStore(a[k], size)\r\n        a[k][$storeBase] = () => stores[$store]\r\n        metadata[$storeFlattened].push(a[k])\r\n\r\n      } else if (isArrayType(a[k])) {\r\n        \r\n        const [type, length] = a[k]\r\n        a[k] = createArrayStore(metadata, type, length)\r\n        a[k][$storeBase] = () => stores[$store]\r\n        metadata[$storeFlattened].push(a[k])\r\n        // Object.seal(a[k])\r\n\r\n      } else if (a[k] instanceof Object) {\r\n        \r\n        a[k] = Object.keys(a[k]).reduce(recursiveTransform, a[k])\r\n        // Object.seal(a[k])\r\n        \r\n      }\r\n\r\n      return a\r\n    }\r\n\r\n    stores[$store] = Object.assign(Object.keys(schema).reduce(recursiveTransform, schema), metadata)\r\n    stores[$store][$storeBase] = () => stores[$store]\r\n\r\n    // Object.seal(stores[$store])\r\n\r\n    return stores[$store]\r\n\r\n  }\r\n}\r\n\r\nexport const free = (store) => {\r\n  delete stores[store[$storeRef]]\r\n}", "export const Uint32SparseSet = (length) => {\r\n  const dense = new Uint32Array(length)\r\n  const sparse = new Uint32Array(length)\r\n\r\n  let cursor = 0\r\n  dense.count = () => cursor + 1\r\n\r\n  const has = val => dense[sparse[val]] === val\r\n\r\n  const add = val => {\r\n    if (has(val)) return\r\n    sparse[val] = cursor\r\n    dense[cursor] = val\r\n\r\n    cursor++\r\n  }\r\n\r\n  const remove = val => {\r\n    if (!has(val)) return\r\n    const index = sparse[val]\r\n    const swapped = dense[cursor]\r\n    if (swapped !== val) {\r\n      dense[index] = swapped\r\n      sparse[swapped] = index\r\n    }\r\n\r\n    cursor--\r\n  }\r\n\r\n  return {\r\n    add,\r\n    remove,\r\n    has,\r\n    sparse,\r\n    dense,\r\n  }\r\n}\r\n\r\nexport const SparseSet = () => {\r\n  const dense = []\r\n  const sparse = []\r\n\r\n  dense.sort = function (comparator) {\r\n    const result = Array.prototype.sort.call(this, comparator)\r\n\r\n    for(let i = 0; i < dense.length; i++) {\r\n      sparse[dense[i]] = i\r\n    }\r\n    \r\n    return result\r\n  }\r\n\r\n  const has = val => dense[sparse[val]] === val\r\n\r\n  const add = val => {\r\n    if (has(val)) return\r\n    sparse[val] = dense.push(val) - 1\r\n  }\r\n\r\n  const remove = val => {\r\n    if (!has(val)) return\r\n    const index = sparse[val]\r\n    const swapped = dense.pop()\r\n    if (swapped !== val) {\r\n      dense[index] = swapped\r\n      sparse[swapped] = index\r\n    }\r\n  }\r\n\r\n  const reset = () => {\r\n    dense.length = 0\r\n    sparse.length = 0\r\n  }\r\n\r\n  return {\r\n    add,\r\n    remove,\r\n    has,\r\n    sparse,\r\n    dense,\r\n    reset,\r\n  }\r\n}", "import { $indexBytes, $indexType, $isEidType, $serializeShadow, $storeBase, $storeFlattened, $tagStore, createShadow } from \"./Storage.js\"\r\nimport { $componentMap, addComponent, hasComponent } from \"./Component.js\"\r\nimport { $entityArray, $entitySparseSet, addEntity, eidToWorld } from \"./Entity.js\"\r\nimport { $localEntities, $localEntityLookup } from \"./World.js\"\r\nimport { SparseSet } from \"./Util.js\"\r\nimport { $modifier } from \"./Query.js\"\r\n\r\nexport const DESERIALIZE_MODE = {\r\n  REPLACE: 0,\r\n  APPEND: 1,\r\n  MAP: 2\r\n}\r\n\r\nlet resized = false\r\n\r\nexport const setSerializationResized = v => { resized = v }\r\n\r\nconst concat = (a,v) => a.concat(v)\r\nconst not = fn => v => !fn(v)\r\n\r\nconst storeFlattened = c => c[$storeFlattened]\r\nconst isFullComponent = storeFlattened\r\nconst isProperty = not(isFullComponent)\r\n\r\nconst isModifier = c => typeof c === \"function\" && c[$modifier]\r\nconst isNotModifier = not(isModifier)\r\n\r\nconst isChangedModifier = c => isModifier(c) && c()[1] === 'changed'\r\n\r\nconst isWorld = w => Object.getOwnPropertySymbols(w).includes($componentMap)\r\n\r\nconst fromModifierToComponent = c => c()[0]\r\n\r\nexport const canonicalize = target => {\r\n\r\n  if (isWorld(target)) return [[],new Map()]\r\n\r\n  // aggregate full components\r\n  const fullComponentProps = target\r\n    .filter(isNotModifier)\r\n    .filter(isFullComponent)\r\n    .map(storeFlattened).reduce(concat, [])\r\n  \r\n  // aggregate changed full components\r\n  const changedComponentProps = target\r\n    .filter(isChangedModifier).map(fromModifierToComponent)\r\n    .filter(isFullComponent)\r\n    .map(storeFlattened).reduce(concat, [])\r\n\r\n  // aggregate props\r\n  const props = target\r\n    .filter(isNotModifier)\r\n    .filter(isProperty)\r\n\r\n  // aggregate changed props\r\n  const changedProps = target\r\n    .filter(isChangedModifier).map(fromModifierToComponent)\r\n    .filter(isProperty)\r\n  \r\n  const componentProps = [...fullComponentProps, ...props, ...changedComponentProps, ...changedProps]\r\n  const allChangedProps = [...changedComponentProps, ...changedProps].reduce((map,prop) => {\r\n    const $ = Symbol()\r\n    createShadow(prop, $)\r\n    map.set(prop, $)\r\n    return map\r\n  }, new Map())\r\n\r\n  return [componentProps, allChangedProps]\r\n}\r\n\r\n/**\r\n * Defines a new serializer which targets the given components to serialize the data of when called on a world or array of EIDs.\r\n *\r\n * @param {object|array} target\r\n * @param {number} [maxBytes=20000000]\r\n * @returns {function} serializer\r\n */\r\nexport const defineSerializer = (target, maxBytes = 20000000) => {\r\n  const worldSerializer = isWorld(target)\r\n\r\n  let [componentProps, changedProps] = canonicalize(target)\r\n\r\n  // TODO: calculate max bytes based on target & recalc upon resize\r\n\r\n  const buffer = new ArrayBuffer(maxBytes)\r\n  const view = new DataView(buffer)\r\n\r\n  const entityComponentCache = new Map()\r\n\r\n  return (ents) => {\r\n\r\n    if (resized) {\r\n      [componentProps, changedProps] = canonicalize(target)\r\n      resized = false\r\n    }\r\n\r\n    if (worldSerializer) {\r\n      componentProps = []\r\n      target[$componentMap].forEach((c, component) => {\r\n        if (component[$storeFlattened])\r\n          componentProps.push(...component[$storeFlattened])\r\n        else componentProps.push(component)\r\n      })\r\n    }\r\n    \r\n    let world\r\n    if (Object.getOwnPropertySymbols(ents).includes($componentMap)) {\r\n      world = ents\r\n      ents = ents[$entityArray]\r\n    } else {\r\n      world = eidToWorld.get(ents[0])\r\n    }\r\n\r\n    let where = 0\r\n\r\n    if (!ents.length) return buffer.slice(0, where)\r\n\r\n    const cache = new Map()\r\n\r\n    // iterate over component props\r\n    for (let pid = 0; pid < componentProps.length; pid++) {\r\n      const prop = componentProps[pid]\r\n      const component = prop[$storeBase]()\r\n      const $diff = changedProps.get(prop)\r\n      const shadow = $diff ? prop[$diff] : null\r\n\r\n      if (!cache.has(component)) cache.set(component, new Map())\r\n\r\n      // write pid\r\n      view.setUint8(where, pid)\r\n      where += 1\r\n\r\n      // save space for entity count\r\n      const countWhere = where\r\n      where += 4\r\n\r\n      let writeCount = 0\r\n      // write eid,val\r\n      for (let i = 0; i < ents.length; i++) {\r\n        const eid = ents[i]\r\n\r\n        let componentCache = entityComponentCache.get(eid)\r\n        if (!componentCache) componentCache = entityComponentCache.set(eid, new Set()).get(eid)\r\n        \r\n        componentCache.add(eid)\r\n        \r\n        const newlyAddedComponent = \r\n          // if we are diffing\r\n          shadow \r\n          // and we have already iterated over this component for this entity\r\n          // retrieve cached value    \r\n          && cache.get(component).get(eid)\r\n          // or if entity did not have component last call\r\n          || !componentCache.has(component)\r\n          // and entity has component this call\r\n          && hasComponent(world, component, eid)\r\n\r\n        cache.get(component).set(eid, newlyAddedComponent)\r\n\r\n        if (newlyAddedComponent) {\r\n          componentCache.add(component)\r\n        } else if (!hasComponent(world, component, eid)) {\r\n          // skip if entity doesn't have this component\r\n          componentCache.delete(component)\r\n          continue\r\n        } \r\n\r\n        \r\n        const rewindWhere = where\r\n\r\n        // write eid\r\n        view.setUint32(where, eid)\r\n        where += 4\r\n\r\n        // if it's a tag store we can stop here\r\n        if (prop[$tagStore]) {\r\n          writeCount++\r\n          continue\r\n        }\r\n\r\n        // if property is an array\r\n        if (ArrayBuffer.isView(prop[eid])) {\r\n          const type = prop[eid].constructor.name.replace('Array', '')\r\n          const indexType = prop[eid][$indexType]\r\n          const indexBytes = prop[eid][$indexBytes]\r\n\r\n          // save space for count of dirty array elements\r\n          const countWhere2 = where\r\n          where += indexBytes\r\n\r\n          let arrayWriteCount = 0\r\n\r\n          // write index,value\r\n          for (let i = 0; i < prop[eid].length; i++) {\r\n\r\n            if (shadow) {\r\n\r\n              const changed = shadow[eid][i] !== prop[eid][i]\r\n              \r\n              // sync shadow\r\n              shadow[eid][i] = prop[eid][i]              \r\n\r\n              // if state has not changed since the last call\r\n              // todo: if newly added then entire component will serialize (instead of only changed values)\r\n              if (!changed && !newlyAddedComponent) {\r\n                // skip writing this value\r\n                continue\r\n              }\r\n            }\r\n            \r\n            // write array index\r\n            view[`set${indexType}`](where, i)\r\n            where += indexBytes\r\n            \r\n            // write value at that index\r\n            const value = prop[eid][i]\r\n            view[`set${type}`](where, value)\r\n            where += prop[eid].BYTES_PER_ELEMENT\r\n            arrayWriteCount++\r\n          }\r\n\r\n          if (arrayWriteCount > 0) {\r\n            // write total element count\r\n            view[`set${indexType}`](countWhere2, arrayWriteCount)\r\n            writeCount++\r\n          } else {\r\n            where = rewindWhere\r\n            continue\r\n          }\r\n        } else {\r\n\r\n          if (shadow) {\r\n\r\n            const changed = shadow[eid] !== prop[eid]\r\n\r\n            shadow[eid] = prop[eid]\r\n\r\n            // do not write value if diffing and no change\r\n            if (!changed && !newlyAddedComponent) {\r\n              // rewind the serializer\r\n              where = rewindWhere\r\n              // skip writing this value\r\n              continue\r\n            }\r\n\r\n          }  \r\n\r\n\r\n          const type = prop.constructor.name.replace('Array', '')\r\n          // set value next [type] bytes\r\n          view[`set${type}`](where, prop[eid])\r\n          where += prop.BYTES_PER_ELEMENT\r\n\r\n          writeCount++\r\n        }\r\n      }\r\n\r\n      if (writeCount > 0) {\r\n        // write how many eid/value pairs were written\r\n        view.setUint32(countWhere, writeCount)\r\n      } else {\r\n        // if nothing was written (diffed with no changes) \r\n        // then move cursor back 5 bytes (remove PID and countWhere space)\r\n        where -= 5\r\n      }\r\n    }\r\n    return buffer.slice(0, where)\r\n  }\r\n}\r\n\r\nconst newEntities = new Map()\r\n\r\n/**\r\n * Defines a new deserializer which targets the given components to deserialize onto a given world.\r\n *\r\n * @param {object|array} target\r\n * @returns {function} deserializer\r\n */\r\nexport const defineDeserializer = (target) => {\r\n  const isWorld = Object.getOwnPropertySymbols(target).includes($componentMap)\r\n  let [componentProps] = canonicalize(target)\r\n\r\n  const deserializedEntities = new Set()\r\n\r\n  return (world, packet, mode=0) => {\r\n\r\n    newEntities.clear()\r\n    \r\n    if (resized) {\r\n      [componentProps] = canonicalize(target)\r\n      resized = false\r\n    }\r\n\r\n    if (isWorld) {\r\n      componentProps = []\r\n      target[$componentMap].forEach((c, component) => {\r\n        if (component[$storeFlattened])\r\n          componentProps.push(...component[$storeFlattened])\r\n        else componentProps.push(component)\r\n      })\r\n    }\r\n\r\n    const localEntities = world[$localEntities]\r\n    const localEntityLookup = world[$localEntityLookup]\r\n\r\n    const view = new DataView(packet)\r\n    let where = 0\r\n\r\n    while (where < packet.byteLength) {\r\n\r\n      // pid\r\n      const pid = view.getUint8(where)\r\n      where += 1\r\n\r\n      // entity count\r\n      const entityCount = view.getUint32(where)\r\n      where += 4\r\n\r\n      // component property\r\n      const prop = componentProps[pid]\r\n\r\n      // Get the entities and set their prop values\r\n      for (let i = 0; i < entityCount; i++) {\r\n        let eid = view.getUint32(where) // throws with [changed, c, changed]\r\n        where += 4\r\n\r\n        if (mode === DESERIALIZE_MODE.MAP) {\r\n          if (localEntities.has(eid)) {\r\n            eid = localEntities.get(eid)\r\n          } else if (newEntities.has(eid)) {\r\n            eid = newEntities.get(eid)\r\n          } else {\r\n            const newEid = addEntity(world)\r\n            localEntities.set(eid, newEid)\r\n            localEntityLookup.set(newEid, eid)\r\n            newEntities.set(eid, newEid)\r\n            eid = newEid\r\n          }\r\n        }\r\n\r\n        if (mode === DESERIALIZE_MODE.APPEND ||  \r\n          mode === DESERIALIZE_MODE.REPLACE && !world[$entitySparseSet].has(eid)\r\n        ) {\r\n          const newEid = newEntities.get(eid) || addEntity(world)\r\n          newEntities.set(eid, newEid)\r\n          eid = newEid\r\n        }\r\n\r\n        const component = prop[$storeBase]()\r\n        if (!hasComponent(world, component, eid)) {\r\n          addComponent(world, component, eid)\r\n        }\r\n\r\n        // add eid to deserialized ents after it has been transformed by MAP mode\r\n        deserializedEntities.add(eid)\r\n\r\n        if (component[$tagStore]) {\r\n          continue\r\n        }\r\n        \r\n        if (ArrayBuffer.isView(prop[eid])) {\r\n          const array = prop[eid]\r\n          const count = view[`get${array[$indexType]}`](where)\r\n          where += array[$indexBytes]\r\n\r\n          // iterate over count\r\n          for (let i = 0; i < count; i++) {\r\n            const index = view[`get${array[$indexType]}`](where)\r\n            where += array[$indexBytes]\r\n\r\n            const value = view[`get${array.constructor.name.replace('Array', '')}`](where)\r\n            where += array.BYTES_PER_ELEMENT\r\n            if (prop[$isEidType]) {\r\n              let localEid\r\n              if (localEntities.has(value)) {\r\n                localEid = localEntities.get(value)\r\n              } else if (newEntities.has(value)) {\r\n                localEid = newEntities.get(value)\r\n              } else {\r\n                const newEid = addEntity(world)\r\n                localEntities.set(value, newEid)\r\n                localEntityLookup.set(newEid, value)\r\n                newEntities.set(value, newEid)\r\n                localEid = newEid\r\n              }\r\n              prop[eid][index] = localEid\r\n            } else prop[eid][index] = value\r\n          }\r\n        } else {\r\n          const value = view[`get${prop.constructor.name.replace('Array', '')}`](where)\r\n          where += prop.BYTES_PER_ELEMENT\r\n\r\n          if (prop[$isEidType]) {\r\n            let localEid\r\n            if (localEntities.has(value)) {\r\n              localEid = localEntities.get(value)\r\n            } else if (newEntities.has(value)) {\r\n              localEid = newEntities.get(value)\r\n            } else {\r\n              const newEid = addEntity(world)\r\n              localEntities.set(value, newEid)\r\n              localEntityLookup.set(newEid, value)\r\n              newEntities.set(value, newEid)\r\n              localEid = newEid\r\n            }\r\n            prop[eid] = localEid\r\n          } else prop[eid] = value\r\n        }\r\n      }\r\n    }\r\n\r\n    const ents = Array.from(deserializedEntities)\r\n\r\n    deserializedEntities.clear()\r\n\r\n    return ents\r\n  }\r\n}", "import { resizeComponents } from './Component.js'\r\nimport { $notQueries, $queries, queryAddEntity, queryCheckEntity, queryRemoveEntity } from './Query.js'\r\nimport { $localEntities, $localEntityLookup, $manualEntityRecycling, $size, resizeWorlds } from './World.js'\r\nimport { setSerializationResized } from './Serialize.js'\r\n\r\nexport const $entityMasks = Symbol('entityMasks')\r\nexport const $entityComponents = Symbol('entityComponents')\r\nexport const $entitySparseSet = Symbol('entitySparseSet')\r\nexport const $entityArray = Symbol('entityArray')\r\nexport const $entityIndices = Symbol('entityIndices')\r\nexport const $removedEntities = Symbol('removedEntities')\r\n\r\nlet defaultSize = 100000\r\n\r\n// need a global EID cursor which all worlds and all components know about\r\n// so that world entities can posess entire rows spanning all component tables\r\nlet globalEntityCursor = 0\r\nlet globalSize = defaultSize\r\nlet resizeThreshold = () => globalSize - (globalSize / 5)\r\n\r\nexport const getGlobalSize = () => globalSize\r\n\r\n// removed eids should also be global to prevent memory leaks\r\nconst removed = []\r\nconst recycled = []\r\n\r\nconst defaultRemovedReuseThreshold = 0.01\r\nlet removedReuseThreshold = defaultRemovedReuseThreshold\r\n\r\nexport const resetGlobals = () => {\r\n  globalSize = defaultSize\r\n  globalEntityCursor = 0\r\n  removedReuseThreshold = defaultRemovedReuseThreshold\r\n  removed.length = 0\r\n  recycled.length = 0\r\n}\r\n\r\nexport const getDefaultSize = () => defaultSize\r\n\r\n/**\r\n * Sets the default maximum number of entities for worlds and component stores.\r\n *\r\n * @param {number} newSize\r\n */\r\nexport const setDefaultSize = newSize => { \r\n  const oldSize = globalSize\r\n\r\n  defaultSize = newSize\r\n  resetGlobals()\r\n\r\n  globalSize = newSize\r\n  resizeWorlds(newSize)\r\n  setSerializationResized(true)\r\n}\r\n\r\n/**\r\n * Sets the number of entities that must be removed before removed entity ids begin to be recycled.\r\n * This should be set to as a % (0-1) of `defaultSize` that you would never likely remove/add on a single frame.\r\n *\r\n * @param {number} newThreshold\r\n */\r\nexport const setRemovedRecycleThreshold = newThreshold => {\r\n  removedReuseThreshold = newThreshold\r\n}\r\n\r\nexport const getEntityCursor = () => globalEntityCursor\r\nexport const getRemovedEntities = () => [...recycled, ...removed]\r\n\r\nexport const eidToWorld = new Map()\r\n\r\nexport const flushRemovedEntities = (world) => {\r\n  if (!world[$manualEntityRecycling]) {\r\n    throw new Error(\"bitECS - cannot flush removed entities, enable feature with the enableManualEntityRecycling function\")\r\n  }\r\n  removed.push(...recycled)\r\n  recycled.length = 0\r\n}\r\n\r\n/**\r\n * Adds a new entity to the specified world.\r\n *\r\n * @param {World} world\r\n * @returns {number} eid\r\n */\r\nexport const addEntity = (world) => {\r\n\r\n  const eid = world[$manualEntityRecycling]\r\n    ? removed.length ? removed.shift() : globalEntityCursor++\r\n    : removed.length > Math.round(globalSize * removedReuseThreshold) ? removed.shift() : globalEntityCursor++\r\n\r\n  if (eid > world[$size]) throw new Error(\"bitECS - max entities reached\")\r\n\r\n  world[$entitySparseSet].add(eid)\r\n  eidToWorld.set(eid, world)\r\n\r\n  world[$notQueries].forEach(q => {\r\n    const match = queryCheckEntity(world, q, eid)\r\n    if (match) queryAddEntity(q, eid)\r\n  })\r\n\r\n  world[$entityComponents].set(eid, new Set())\r\n\r\n  return eid\r\n}\r\n\r\n/**\r\n * Removes an existing entity from the specified world.\r\n *\r\n * @param {World} world\r\n * @param {number} eid\r\n */\r\nexport const removeEntity = (world, eid) => {\r\n  // Check if entity is already removed\r\n  if (!world[$entitySparseSet].has(eid)) return\r\n\r\n  // Remove entity from all queries\r\n  // TODO: archetype graph\r\n  world[$queries].forEach(q => {\r\n    queryRemoveEntity(world, q, eid)\r\n  })\r\n\r\n  // Free the entity\r\n  if (world[$manualEntityRecycling])\r\n    recycled.push(eid)\r\n  else\r\n    removed.push(eid)\r\n\r\n  // remove all eid state from world\r\n  world[$entitySparseSet].remove(eid)\r\n  world[$entityComponents].delete(eid)\r\n\r\n  // remove from deserializer mapping\r\n  world[$localEntities].delete(world[$localEntityLookup].get(eid))\r\n  world[$localEntityLookup].delete(eid)\r\n\r\n  // Clear entity bitmasks\r\n  for (let i = 0; i < world[$entityMasks].length; i++) world[$entityMasks][i][eid] = 0\r\n}\r\n\r\n/**\r\n *  Returns an array of components that an entity possesses.\r\n *\r\n * @param {*} world\r\n * @param {*} eid\r\n */\r\nexport const getEntityComponents = (world, eid) => {\r\n  if (eid === undefined) throw new Error('bitECS - entity is undefined.')\r\n  if (!world[$entitySparseSet].has(eid)) throw new Error('bitECS - entity does not exist in the world.')\r\n  return Array.from(world[$entityComponents].get(eid))\r\n}\r\n\r\n/**\r\n * Checks the existence of an entity in a world\r\n * \r\n * @param {World} world \r\n * @param {number} eid \r\n */\r\nexport const entityExists = (world, eid) => world[$entitySparseSet].has(eid)\r\n", "import { SparseSet } from './Util.js'\r\nimport { $queryShadow, $storeFlattened, $tagStore, createShadow } from './Storage.js'\r\nimport { $componentMap, registerComponent } from './Component.js'\r\nimport { $entityMasks, $entityArray, getEntityCursor, $entitySparseSet } from './Entity.js'\r\n\r\nexport const $modifier = Symbol(\"$modifier\")\r\n\r\nfunction modifier(c, mod) {\r\n  const inner = () => [c, mod]\r\n  inner[$modifier] = true\r\n  return inner\r\n}\r\n\r\nexport const Not = (c) => modifier(c, 'not')\r\nexport const Or = (c) => modifier(c, 'or')\r\nexport const Changed = (c) => modifier(c, 'changed')\r\n\r\nexport function Any(...comps) { return function QueryAny() { return comps } }\r\nexport function All(...comps) { return function QueryAll() { return comps } }\r\nexport function None(...comps) { return function QueryNone() { return comps } }\r\n\r\nexport const $queries = Symbol('queries')\r\nexport const $notQueries = Symbol('notQueries')\r\n\r\nexport const $queryAny = Symbol('queryAny')\r\nexport const $queryAll = Symbol('queryAll')\r\nexport const $queryNone = Symbol('queryNone')\r\n\r\nexport const $queryMap = Symbol('queryMap')\r\nexport const $dirtyQueries = Symbol('$dirtyQueries')\r\nexport const $queryComponents = Symbol('queryComponents')\r\nexport const $enterQuery = Symbol('enterQuery')\r\nexport const $exitQuery = Symbol('exitQuery')\r\n\r\nconst empty = Object.freeze([])\r\n\r\n/**\r\n * Given an existing query, returns a new function which returns entities who have been added to the given query since the last call of the function.\r\n *\r\n * @param {function} query\r\n * @returns {function} enteredQuery\r\n */\r\nexport const enterQuery = query => world => {\r\n  if (!world[$queryMap].has(query)) registerQuery(world, query)\r\n  const q = world[$queryMap].get(query)\r\n  if (q.entered.dense.length === 0) {\r\n    return empty\r\n  } else {\r\n    const results = q.entered.dense.slice()\r\n    q.entered.reset()\r\n    return results\r\n  }\r\n}\r\n\r\n/**\r\n * Given an existing query, returns a new function which returns entities who have been removed from the given query since the last call of the function.\r\n *\r\n * @param {function} query\r\n * @returns {function} enteredQuery\r\n */\r\nexport const exitQuery = query => world => {\r\n  if (!world[$queryMap].has(query)) registerQuery(world, query)\r\n  const q = world[$queryMap].get(query)\r\n  if (q.exited.dense.length === 0) {\r\n    return empty\r\n  } else {\r\n    const results = q.exited.dense.slice()\r\n    q.exited.reset()\r\n    return results\r\n  }\r\n}\r\n\r\nexport const registerQuery = (world, query) => {\r\n\r\n  const components = []\r\n  const notComponents = []\r\n  const changedComponents = []\r\n\r\n  query[$queryComponents].forEach(c => {\r\n    if (typeof c === \"function\" && c[$modifier]) {\r\n      const [comp, mod] = c()\r\n      if (!world[$componentMap].has(comp)) registerComponent(world, comp)\r\n      if (mod === 'not') {\r\n        notComponents.push(comp)\r\n      }\r\n      if (mod === 'changed') {\r\n        changedComponents.push(comp)\r\n        components.push(comp)\r\n      }\r\n      // if (mod === 'all') {\r\n      //   allComponents.push(comp)\r\n      // }\r\n      // if (mod === 'any') {\r\n      //   anyComponents.push(comp)\r\n      // }\r\n      // if (mod === 'none') {\r\n      //   noneComponents.push(comp)\r\n      // }\r\n    } else {\r\n      if (!world[$componentMap].has(c)) registerComponent(world, c)\r\n      components.push(c)\r\n    }\r\n  })\r\n\r\n\r\n  const mapComponents = c => world[$componentMap].get(c)\r\n\r\n  const allComponents = components.concat(notComponents).map(mapComponents)\r\n\r\n  // const sparseSet = Uint32SparseSet(getGlobalSize())\r\n  const sparseSet = SparseSet()\r\n\r\n  const archetypes = []\r\n  // const changed = SparseSet()\r\n  const changed = []\r\n  const toRemove = SparseSet()\r\n  const entered = SparseSet()\r\n  const exited = SparseSet()\r\n\r\n  const generations = allComponents\r\n    .map(c => c.generationId)\r\n    .reduce((a,v) => {\r\n      if (a.includes(v)) return a\r\n      a.push(v)\r\n      return a\r\n    }, [])\r\n\r\n  const reduceBitflags = (a,c) => {\r\n    if (!a[c.generationId]) a[c.generationId] = 0\r\n    a[c.generationId] |= c.bitflag\r\n    return a\r\n  }\r\n  const masks = components\r\n    .map(mapComponents)\r\n    .reduce(reduceBitflags, {})\r\n\r\n  const notMasks = notComponents\r\n    .map(mapComponents)\r\n    .reduce(reduceBitflags, {})\r\n\r\n  // const orMasks = orComponents\r\n  //   .map(mapComponents)\r\n  //   .reduce(reduceBitmasks, {})\r\n\r\n  const hasMasks = allComponents\r\n    .reduce(reduceBitflags, {})\r\n\r\n  const flatProps = components\r\n    .filter(c => !c[$tagStore])\r\n    .map(c => Object.getOwnPropertySymbols(c).includes($storeFlattened) ? c[$storeFlattened] : [c])\r\n    .reduce((a,v) => a.concat(v), [])\r\n\r\n  const shadows = []\r\n\r\n  const q = Object.assign(sparseSet, {\r\n    archetypes,\r\n    changed,\r\n    components,\r\n    notComponents,\r\n    changedComponents,\r\n    allComponents,\r\n    masks,\r\n    notMasks,\r\n    // orMasks,\r\n    hasMasks,\r\n    generations,\r\n    flatProps,\r\n    toRemove,\r\n    entered,\r\n    exited,\r\n    shadows,\r\n  })\r\n\r\n  world[$queryMap].set(query, q)\r\n  world[$queries].add(q)\r\n  \r\n  allComponents.forEach(c => {\r\n    c.queries.add(q)\r\n  })\r\n\r\n  if (notComponents.length) world[$notQueries].add(q)\r\n\r\n  for (let eid = 0; eid < getEntityCursor(); eid++) {\r\n    if (!world[$entitySparseSet].has(eid)) continue\r\n    const match = queryCheckEntity(world, q, eid)\r\n    if (match) queryAddEntity(q, eid)\r\n  }\r\n}\r\n\r\nconst generateShadow = (q, pid) => {\r\n  const $ = Symbol()\r\n  const prop = q.flatProps[pid]\r\n  createShadow(prop, $)\r\n  q.shadows[pid] = prop[$]\r\n  return prop[$]\r\n}\r\n\r\nconst diff = (q, clearDiff) => {\r\n  if (clearDiff) q.changed = []\r\n  const { flatProps, shadows } = q\r\n  for (let i = 0; i < q.dense.length; i++) {\r\n    const eid = q.dense[i]\r\n    let dirty = false\r\n    for (let pid = 0; pid < flatProps.length; pid++) {\r\n      const prop = flatProps[pid]\r\n      const shadow = shadows[pid] || generateShadow(q, pid)\r\n      if (ArrayBuffer.isView(prop[eid])) {\r\n        for (let i = 0; i < prop[eid].length; i++) {\r\n          if (prop[eid][i] !== shadow[eid][i]) {\r\n            dirty = true\r\n            break\r\n          }\r\n        }\r\n        shadow[eid].set(prop[eid])\r\n      } else {\r\n        if (prop[eid] !== shadow[eid]) {\r\n          dirty = true\r\n          shadow[eid] = prop[eid]\r\n        }\r\n      }\r\n    }\r\n    if (dirty) q.changed.push(eid)\r\n  }\r\n  return q.changed\r\n}\r\n\r\n// const queryEntityChanged = (q, eid) => {\r\n//   if (q.changed.has(eid)) return\r\n//   q.changed.add(eid)\r\n// }\r\n\r\n// export const entityChanged = (world, component, eid) => {\r\n//   const { changedQueries } = world[$componentMap].get(component)\r\n//   changedQueries.forEach(q => {\r\n//     const match = queryCheckEntity(world, q, eid)\r\n//     if (match) queryEntityChanged(q, eid)\r\n//   })\r\n// }\r\n\r\nconst flatten = (a,v) => a.concat(v)\r\n\r\nconst aggregateComponentsFor = mod => x => x.filter(f => f.name === mod().constructor.name).reduce(flatten)\r\n\r\nconst getAnyComponents = aggregateComponentsFor(Any)\r\nconst getAllComponents = aggregateComponentsFor(All)\r\nconst getNoneComponents = aggregateComponentsFor(None)\r\n\r\n/**\r\n * Defines a query function which returns a matching set of entities when called on a world.\r\n *\r\n * @param {array} components\r\n * @returns {function} query\r\n */\r\n\r\nexport const defineQuery = (...args) => {\r\n  let components\r\n  let any, all, none\r\n  if (Array.isArray(args[0])) {\r\n    components = args[0]\r\n  } else {\r\n    // any = getAnyComponents(args)\r\n    // all = getAllComponents(args)\r\n    // none = getNoneComponents(args)\r\n  }\r\n  \r\n\r\n  if (components === undefined || components[$componentMap] !== undefined) {\r\n    return world => world ? world[$entityArray] : components[$entityArray]\r\n  }\r\n\r\n  const query = function (world, clearDiff=true) {\r\n    if (!world[$queryMap].has(query)) registerQuery(world, query)\r\n\r\n    const q = world[$queryMap].get(query)\r\n\r\n    commitRemovals(world)\r\n\r\n    if (q.changedComponents.length) return diff(q, clearDiff)\r\n    // if (q.changedComponents.length) return q.changed.dense\r\n\r\n    return q.dense\r\n  }\r\n\r\n  query[$queryComponents] = components\r\n  query[$queryAny] = any\r\n  query[$queryAll] = all\r\n  query[$queryNone] = none\r\n\r\n  return query\r\n}\r\n\r\nconst bin = value => {\r\n  if (!Number.isSafeInteger(value)) {\r\n    throw new TypeError('value must be a safe integer');\r\n  }\r\n\r\n  const negative = value < 0;\r\n  const twosComplement = negative ? Number.MAX_SAFE_INTEGER + value + 1 : value;\r\n  const signExtend = negative ? '1' : '0';\r\n\r\n  return twosComplement.toString(2).padStart(4, '0').padStart(0, signExtend);\r\n}\r\n\r\n// TODO: archetype graph\r\nexport const queryCheckEntity = (world, q, eid) => {\r\n  const { masks, notMasks, generations } = q\r\n  let or = 0\r\n  for (let i = 0; i < generations.length; i++) {\r\n    const generationId = generations[i]\r\n    const qMask = masks[generationId]\r\n    const qNotMask = notMasks[generationId]\r\n    // const qOrMask = orMasks[generationId]\r\n    const eMask = world[$entityMasks][generationId][eid]\r\n    \r\n    // any\r\n    // if (qOrMask && (eMask & qOrMask) !== qOrMask) {\r\n    //   continue\r\n    // }\r\n    // not all \r\n    // if (qNotMask && (eMask & qNotMask) === qNotMask) {\r\n    // }\r\n    // not any\r\n    if (qNotMask && (eMask & qNotMask) !== 0) {\r\n      return false\r\n    }\r\n    // all\r\n    if (qMask && (eMask & qMask) !== qMask) {\r\n      return false\r\n    }\r\n  }\r\n  return true\r\n}\r\n\r\nexport const queryCheckComponent = (q, c) => {\r\n  const { generationId, bitflag } = c\r\n  const { hasMasks } = q\r\n  const mask = hasMasks[generationId]\r\n  return (mask & bitflag) === bitflag\r\n}\r\n\r\nexport const queryAddEntity = (q, eid) => {\r\n  q.toRemove.remove(eid)\r\n  // if (!q.has(eid)) \r\n  q.entered.add(eid)\r\n  q.add(eid)\r\n}\r\n\r\nconst queryCommitRemovals = (q) => {\r\n  for (let i = q.toRemove.dense.length-1; i >= 0; i--) {\r\n    const eid = q.toRemove.dense[i]\r\n    q.toRemove.remove(eid)\r\n    q.remove(eid)\r\n  }\r\n}\r\n\r\nexport const commitRemovals = (world) => {\r\n  if (!world[$dirtyQueries].size) return\r\n  world[$dirtyQueries].forEach(queryCommitRemovals)\r\n  world[$dirtyQueries].clear()\r\n}\r\n\r\nexport const queryRemoveEntity = (world, q, eid) => {\r\n  if (!q.has(eid) || q.toRemove.has(eid)) return\r\n  q.toRemove.add(eid)\r\n  world[$dirtyQueries].add(q)\r\n  q.exited.add(eid)\r\n}\r\n\r\n\r\n/**\r\n * Resets a Changed-based query, clearing the underlying list of changed entities.\r\n *\r\n * @param {World} world\r\n * @param {function} query\r\n */\r\nexport const resetChangedQuery = (world, query) => {\r\n  const q = world[$queryMap].get(query)\r\n  q.changed = []\r\n}\r\n\r\n/**\r\n * Removes a query from a world.\r\n *\r\n * @param {World} world\r\n * @param {function} query\r\n */\r\nexport const removeQuery = (world, query) => {\r\n  const q = world[$queryMap].get(query)\r\n  world[$queries].delete(q)\r\n  world[$queryMap].delete(query)\r\n}", "import { $storeSize, createStore, resetStoreFor, resizeStore } from './Storage.js'\r\nimport { $queries, queryAddEntity, queryRemoveEntity, queryCheckEntity, commitRemovals } from './Query.js'\r\nimport { $bitflag, $size } from './World.js'\r\nimport { $entityMasks, getDefaultSize, eidToWorld, $entityComponents, getGlobalSize, $entitySparseSet } from './Entity.js'\r\n\r\nexport const $componentMap = Symbol('componentMap')\r\n\r\nexport const components = []\r\n\r\nexport const resizeComponents = (size) => {\r\n  components.forEach(component => resizeStore(component, size))\r\n}\r\n\r\n\r\n/**\r\n * Defines a new component store.\r\n *\r\n * @param {object} schema\r\n * @returns {object}\r\n */\r\nexport const defineComponent = (schema, size) => {\r\n  const component = createStore(schema, size || getGlobalSize())\r\n  if (schema && Object.keys(schema).length) components.push(component)\r\n  return component\r\n}\r\n\r\nexport const incrementBitflag = (world) => {\r\n  world[$bitflag] *= 2\r\n  if (world[$bitflag] >= 2**31) {\r\n    world[$bitflag] = 1\r\n    world[$entityMasks].push(new Uint32Array(world[$size]))\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Registers a component with a world.\r\n *\r\n * @param {World} world\r\n * @param {Component} component\r\n */\r\nexport const registerComponent = (world, component) => {\r\n  if (!component) throw new Error(`bitECS - Cannot register null or undefined component`)\r\n\r\n  const queries = new Set()\r\n  const notQueries = new Set()\r\n  const changedQueries = new Set()\r\n\r\n  world[$queries].forEach(q => {\r\n    if (q.allComponents.includes(component)) {\r\n      queries.add(q)\r\n    }\r\n  })\r\n\r\n  world[$componentMap].set(component, { \r\n    generationId: world[$entityMasks].length - 1,\r\n    bitflag: world[$bitflag],\r\n    store: component,\r\n    queries,\r\n    notQueries,\r\n    changedQueries,\r\n  })\r\n\r\n  incrementBitflag(world)\r\n}\r\n\r\n/**\r\n * Registers multiple components with a world.\r\n *\r\n * @param {World} world\r\n * @param {Component} components\r\n */\r\nexport const registerComponents = (world, components) => {\r\n  components.forEach(c => registerComponent(world, c))\r\n}\r\n\r\n/**\r\n * Checks if an entity has a component.\r\n *\r\n * @param {World} world\r\n * @param {Component} component\r\n * @param {number} eid\r\n * @returns {boolean}\r\n */\r\nexport const hasComponent = (world, component, eid) => {\r\n  const registeredComponent = world[$componentMap].get(component)\r\n  if (!registeredComponent) return false\r\n  const { generationId, bitflag } = registeredComponent\r\n  const mask = world[$entityMasks][generationId][eid]\r\n  return (mask & bitflag) === bitflag\r\n}\r\n\r\n/**\r\n * Adds a component to an entity\r\n *\r\n * @param {World} world\r\n * @param {Component} component\r\n * @param {number} eid\r\n * @param {boolean} [reset=false]\r\n */\r\nexport const addComponent = (world, component, eid, reset=false) => {\r\n  if (eid === undefined) throw new Error('bitECS - entity is undefined.')\r\n  if (!world[$entitySparseSet].has(eid)) throw new Error('bitECS - entity does not exist in the world.')\r\n  if (!world[$componentMap].has(component)) registerComponent(world, component)\r\n  if (hasComponent(world, component, eid)) return\r\n\r\n  const c = world[$componentMap].get(component)\r\n  const { generationId, bitflag, queries, notQueries } = c\r\n    \r\n  // Add bitflag to entity bitmask\r\n  world[$entityMasks][generationId][eid] |= bitflag\r\n\r\n  // todo: archetype graph\r\n  queries.forEach(q => {\r\n    // remove this entity from toRemove if it exists in this query\r\n    q.toRemove.remove(eid)\r\n    const match = queryCheckEntity(world, q, eid)\r\n    if (match) {\r\n      q.exited.remove(eid)\r\n      queryAddEntity(q, eid)\r\n    }\r\n    if (!match) {\r\n      q.entered.remove(eid)\r\n      queryRemoveEntity(world, q, eid)\r\n    }\r\n  })\r\n\r\n  world[$entityComponents].get(eid).add(component)\r\n\r\n  // Zero out each property value\r\n  if (reset) resetStoreFor(component, eid)\r\n}\r\n\r\n/**\r\n * Removes a component from an entity and resets component state unless otherwise specified.\r\n *\r\n * @param {World} world\r\n * @param {Component} component\r\n * @param {number} eid\r\n * @param {boolean} [reset=true]\r\n */\r\nexport const removeComponent = (world, component, eid, reset=true) => {\r\n  if (eid === undefined) throw new Error('bitECS - entity is undefined.')\r\n  if (!world[$entitySparseSet].has(eid)) throw new Error('bitECS - entity does not exist in the world.')\r\n  if (!hasComponent(world, component, eid)) return\r\n\r\n  const c = world[$componentMap].get(component)\r\n  const { generationId, bitflag, queries } = c\r\n\r\n  // Remove flag from entity bitmask\r\n  world[$entityMasks][generationId][eid] &= ~bitflag\r\n  \r\n  // todo: archetype graph\r\n  queries.forEach(q => {\r\n    // remove this entity from toRemove if it exists in this query\r\n    q.toRemove.remove(eid)\r\n    const match = queryCheckEntity(world, q, eid)\r\n    if (match) {\r\n      q.exited.remove(eid)\r\n      queryAddEntity(q, eid)\r\n    }\r\n    if (!match) {\r\n      q.entered.remove(eid)\r\n      queryRemoveEntity(world, q, eid)\r\n    }\r\n  })\r\n\r\n  world[$entityComponents].get(eid).delete(component)\r\n\r\n  // Zero out each property value\r\n  if (reset) resetStoreFor(component, eid)\r\n}\r\n", "import { $componentMap } from './Component.js'\r\nimport { $queryMap, $queries, $dirtyQueries, $notQueries } from './Query.js'\r\nimport { $entityArray, $entityComponents, $entityMasks, $entitySparseSet, getGlobalSize, removeEntity } from './Entity.js'\r\nimport { resize } from './Storage.js'\r\nimport { SparseSet } from './Util.js'\r\n\r\nexport const $size = Symbol('size')\r\nexport const $resizeThreshold = Symbol('resizeThreshold')\r\nexport const $bitflag = Symbol('bitflag')\r\nexport const $archetypes = Symbol('archetypes')\r\nexport const $localEntities = Symbol('localEntities')\r\nexport const $localEntityLookup = Symbol('localEntityLookup')\r\nexport const $manualEntityRecycling = Symbol('manualEntityRecycling')\r\n\r\nexport const worlds = []\r\n\r\nexport const resizeWorlds = (size) => {\r\n  worlds.forEach(world => {\r\n    world[$size] = size\r\n\r\n    for (let i = 0; i < world[$entityMasks].length; i++) {\r\n      const masks = world[$entityMasks][i];\r\n      world[$entityMasks][i] = resize(masks, size)\r\n    }\r\n    \r\n    world[$resizeThreshold] = world[$size] - (world[$size] / 5)\r\n  })\r\n}\r\n\r\n/**\r\n * Creates a new world.\r\n *\r\n * @returns {object}\r\n */\r\nexport const createWorld = (...args) => {\r\n  const world = typeof args[0] === 'object'\r\n    ? args[0]\r\n    : {}\r\n  const size = typeof args[0] === 'number' \r\n    ? args[0] \r\n    : typeof args[1] === 'number' \r\n      ? args[1] \r\n      : getGlobalSize()\r\n  resetWorld(world, size)\r\n  worlds.push(world)\r\n  return world\r\n}\r\n\r\nexport const enableManualEntityRecycling = (world) => {\r\n  world[$manualEntityRecycling] = true\r\n}\r\n\r\n/**\r\n * Resets a world.\r\n *\r\n * @param {World} world\r\n * @returns {object}\r\n */\r\nexport const resetWorld = (world, size = getGlobalSize()) => {\r\n  world[$size] = size\r\n\r\n  if (world[$entityArray]) world[$entityArray].forEach(eid => removeEntity(world, eid))\r\n\r\n  world[$entityMasks] = [new Uint32Array(size)]\r\n  world[$entityComponents] = new Map()\r\n  world[$archetypes] = []\r\n\r\n  world[$entitySparseSet] = SparseSet()\r\n  world[$entityArray] = world[$entitySparseSet].dense\r\n\r\n  world[$bitflag] = 1\r\n\r\n  world[$componentMap] = new Map()\r\n\r\n  world[$queryMap] = new Map()\r\n  world[$queries] = new Set()\r\n  world[$notQueries] = new Set()\r\n  world[$dirtyQueries] = new Set()\r\n\r\n  world[$localEntities] = new Map()\r\n  world[$localEntityLookup] = new Map()\r\n\r\n  world[$manualEntityRecycling] = false\r\n\r\n  return world\r\n}\r\n\r\n/**\r\n * Deletes a world.\r\n *\r\n * @param {World} world\r\n */\r\nexport const deleteWorld = (world) => {\r\n  Object.getOwnPropertySymbols(world).forEach($ => { delete world[$] })\r\n  Object.keys(world).forEach(key => { delete world[key] })\r\n  worlds.splice(worlds.indexOf(world), 1)\r\n}\r\n\r\n/**\r\n * Returns all components registered to a world\r\n * \r\n * @param {World} world \r\n * @returns Array\r\n */\r\nexport const getWorldComponents = (world) => Array.from(world[$componentMap].keys())\r\n\r\n/**\r\n * Returns all existing entities in a world\r\n * \r\n * @param {World} world \r\n * @returns Array\r\n */\r\nexport const getAllEntities = (world) => world[$entitySparseSet].dense.slice(0)", "/**\r\n * Defines a new system function.\r\n *\r\n * @param {function} update\r\n * @returns {function}\r\n */\r\n export const defineSystem = (update) => (world, ...args) => {\r\n  update(world, ...args)\r\n  return world\r\n}", "import { createWorld, resetWorld, deleteWorld, getWorldComponents, getAllEntities, enableManualEntityRecycling } from './World.js'\r\nimport { addEntity, removeEntity, setDefaultSize, setRemovedRecycleThreshold, getEntityComponents, entityExists, flushRemovedEntities, resetGlobals } from './Entity.js'\r\nimport { defineComponent, registerComponent, registerComponents, hasComponent, addComponent, removeComponent } from './Component.js'\r\nimport { defineSystem } from './System.js'\r\nimport { defineQuery, enterQuery, exitQuery, Changed, Not, commitRemovals, resetChangedQuery, removeQuery } from './Query.js'\r\nimport { defineSerializer, defineDeserializer, DESERIALIZE_MODE } from './Serialize.js'\r\nimport { parentArray } from './Storage.js'\r\nimport { TYPES_ENUM } from './Constants.js'\r\n\r\nexport const pipe = (...fns) => (input) => {\r\n  let tmp = input\r\n  for (let i = 0; i < fns.length; i++) {\r\n    const fn = fns[i]\r\n    tmp = fn(tmp)\r\n  }\r\n  return tmp\r\n}\r\n\r\nexport const Types = TYPES_ENUM\r\n\r\nexport {\r\n\r\n  setDefaultSize,\r\n  setRemovedRecycleThreshold,\r\n  createWorld,\r\n  resetWorld,\r\n  deleteWorld,\r\n  addEntity,\r\n  removeEntity,\r\n  entityExists,\r\n  getWorldComponents,\r\n  enableManualEntityRecycling,\r\n  flushRemovedEntities,\r\n  getAllEntities,\r\n  \r\n  registerComponent,\r\n  registerComponents,\r\n  defineComponent,\r\n  addComponent,\r\n  removeComponent,\r\n  hasComponent,\r\n  getEntityComponents,\r\n\r\n  defineQuery,\r\n  Changed,\r\n  Not,\r\n  enterQuery,\r\n  exitQuery,\r\n  commitRemovals,\r\n  resetChangedQuery,\r\n  removeQuery,\r\n\r\n  defineSystem,\r\n  \r\n  defineSerializer,\r\n  defineDeserializer,\r\n  DESERIALIZE_MODE,\r\n\r\n  parentArray,\r\n\r\n  resetGlobals\r\n\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
